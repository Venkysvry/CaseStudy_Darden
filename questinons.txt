Java 8 Stream API's  https://youtu.be/KGvmG6sxMds?si=2_osTP7XZvQUlSaC
Java notes:
https://www.youtube.com/playlist?list=PL6W8uoQQ2c63f469AyV78np0rbxRFppkx
 
string buffer and builder
 
Java 11 features -> https://www.youtube.com/watch?v=4EBA7xyw4rI&ab_channel=AshokIT
Java 17 features -> https://www.youtube.com/watch?v=6zmjg_ZEoH8&ab_channel=Geekific
 
 
SQL -> https://www.youtube.com/watch?v=yMqldbY2AAg&ab_channel=ByteByteGo - done
https://youtu.be/LsRagOpaXEg?si=tfSVWZn0HHYhHa7z - done
https://www.youtube.com/watch?v=RZc4QSRRk98&ab_channel=CrackConcepts - done
 
 
Hibernate -> https://www.youtube.com/playlist?list=PLsyeobzWxl7qBZtsEvp_n2A7sJs2MpF3r - done
https://www.youtube.com/watch?v=yRlkCuN07c8&ab_channel=in28minutes-GetCloudCertified - done
 
 
Spring, spring jdbc, spring mvc: https://www.youtube.com/playlist?list=PLlhM4lkb2sEgJDGj2zOJnp0y5A5E6li1k
https://youtu.be/D6MO62aJ_-k?si=awiOdZ8h_rDOEEj9
 
Annotations and types: https://www.geeksforgeeks.org/spring-framework-annotations/?ref=lbp
 
Spring boot exception handling : https://www.youtube.com/watch?v=gPnd-hzM_6A&ab_channel=JavaTechie
https://www.youtube.com/watch?v=zTAHY0SLQAg&ab_channel=in28minutes-GetCloudCertified - done
 
 
Spring jpa: https://www.youtube.com/playlist?list=PLGRDMO4rOGcPtMMl1DD2cu3GBPZloHOS_  - done
 
Spring security: https://www.youtube.com/watch?v=h-9vhFeM3MY&t=105s&ab_channel=Amigoscode
https://www.youtube.com/watch?v=_GSHvvken2k&ab_channel=SergeyTech
https://www.youtube.com/watch?v=us0VjFiHogo&ab_channel=DanVega
https://youtu.be/b9O9NI-RJ3o?si=XAekCT0nYvfm5IGx
 
 
spring AOP: https://www.youtube.com/watch?v=Og9Fyew8ltQ&ab_channel=in28minutes-GetCloudCertified
https://youtu.be/HhsAw8GVogQ?si=BIq6sw8Okvz5s4Td
 
 
SPring batch: https://www.youtube.com/watch?v=eohUc-kRUPw&ab_channel=in28minutes-GetCloudCertified
https://www.youtube.com/watch?v=16bq_N55f_s&ab_channel=TechPrimers
 
 
REST api:
spring boot and rest : https://youtu.be/gPnd-hzM_6A?si=BAb-GOJTQDlBwgob
https://youtu.be/ECAhXdFrBaE?si=E4AY2lGK0mkCei_m
https://youtu.be/_S013liiM8s?si=EggFxiwXD2aF4GNC
https://youtu.be/jo6IEX-v3LM?si=xa9oA63ilUcEXKaQ
https://youtu.be/fzTl-Dr99aw?si=_fqRVcjf-vxXxqX5
https://youtu.be/ECAhXdFrBaE?si=e2q6LPVKOvvmews3
 
 
Kafka: https://youtu.be/rVqAoUIPO7I?si=b26sqbRiM9CNXMMj
Avro and schema register: https://youtu.be/u0kRK-qbopk?si=GSdsZMWK1arJREmj
Retry and exception handling: https://youtu.be/aNBSd7T-RGA?si=uxFdewZc1lD7KxZN
https://youtu.be/x4k1XEjNzYQ?si=udE8QYkbmTuKO1ZJ
https://youtu.be/_5mu7lZz5X4?si=lXiSCbFkBdnAtXZ_
 
Graphql and spring boot: https://youtu.be/GJc36OKFQ_M?si=fGsTYX3V7rbAxTF6
 
Swagger plus spring boot: https://youtu.be/rsAigwGmTf8?si=O_e-oUJLxtpk7Y32
 
JWT plus spring boot : https://youtu.be/X80nJ5T7YpE?si=eOflqi-UZ6ohJ1Yk
https://youtu.be/GH7L4D8Q_ak?si=zM0Q-D4bC0YXgmoE
https://youtu.be/KxqlJblhzfI?si=XjbCzbyrcAhV3pff
 
SPring framework 6 and spring boot 3: https://youtu.be/haVMaDiAGSw?si=eemMwR04P4BdGSYU
https://youtu.be/WJutdzX9hl0?si=D99hZ5Ab8Ws4jOv9
https://youtu.be/btvh21K3yvU?si=sgsQeySJWozyngkP
https://youtu.be/BWaQFX79vO8?si=-0N3q102FMPZg5cl
https://youtu.be/4_jey1hfEw0?si=6d-eE4KFXEFJp5FA
 
 
ACID: https://youtu.be/-GS0OxFJsYQ?si=j4IXeRj6gyl4P2Na - done
https://youtu.be/GAe5oB742dw?si=T4usQDc4uo4e8U87 - done
CAP: https://youtu.be/BHqjEjzAicA?si=HWHhBt-LxzkW-KN9 - done
BASE: https://youtu.be/l8SoqbLNN7Q?si=-1fLOty8fLolY15u - done
 
 
Docker:
https://youtu.be/52SmfrVctB0?si=tZB410fRMsqjna_X
 
Kubernetes:
https://youtu.be/TlHvYWVUZyc?si=o2XX-9tOibR5TTYG
https://youtu.be/umXEmn3cMWY?si=x30f8wlyMq-IAOAh
https://youtu.be/F4U1KsTnVyQ?si=EVgPurFt-lT4lNar
https://youtu.be/RQbc_Yjb9ls?si=MkTL2N1ay8EomX7S
https://youtu.be/GhZi4DxaxxE?si=bFU_37QPAVURTgEX
 
Micorservices:
 
https://youtu.be/lTAcCNbJ7KE?si=Q1S9pGZcJsGdrm6n
https://youtu.be/lL_j7ilk7rc?si=QVcLjlJ60dCg9KoI
https://youtu.be/f9TLjSA9dBs?si=BRsyp5BRChmUE_St
https://www.udemy.com/course/understanding-microservices-architecture/
 
API gateway:
https://youtu.be/6ULyxuHKxg8?si=3XpgxJzTj7oiPkEp
https://youtu.be/2q1MlfFhWhQ?si=cgtbx0WMRMpphj9X
https://youtu.be/b4koVYp2FE8?si=My4FvE9O1ZaVzSLJ
https://youtu.be/6Ts4UdbIs-o?si=UHhzD8xwk0j2IMb5
https://youtu.be/qODoDq5_hAM?si=HglPvdx98mWFNXwV
 
Service registry:
https://youtu.be/lUC7fBYwXOs?si=4_0XjkyZuBI0SD0T
https://www.youtube.com/watch?v=EeQRAxXWDF4&t=28192s&ab_channel=EmbarkX%7CLearnProgramming
 
API vs loadbalancing:
https://youtu.be/L9QRsb0oLv4?si=8DxzYRGP4dOXnAJ-
 
Admin server:
https://youtu.be/pVe_fye2Ge0?si=6bA1yFF4KOupwvtd
 
Zipkin vs jaeger:
https://youtu.be/lJ_XAol-OKM?si=AGDBm24wyn1dd4S2
 
security with jwt and keycloak:
https://youtu.be/MWvnmyLRUik?si=YvC2VHxciYHkmkqv
https://youtu.be/qODoDq5_hAM?si=hYJgxF6iH8Z391gk
https://youtu.be/KpITcN7O53Y?si=0xlSP9i4I5XTgzmL
 
Config server:
https://youtu.be/ArOV5VIShq0?si=Mjs0D9-A9P2tzBCW
https://youtu.be/kq8rVPnWiBY?si=DkqBV2Pc2V_nYIPm
 
feign client:
https://youtu.be/_MMf2SvNqxo?si=uPqFfNU0nBlEEdwx
https://youtu.be/GpqnYd8VR3k?si=Po3zj5k-V3GuMQUo
 
 
logging:
https://youtu.be/M19XC0zJUrA?si=VxPn_t8zlWyIUX87
 
SPring cloud config server:
 
 
 
design patterns:
https://youtu.be/aOen1-pQLZg?si=pKIhpksYT6pzPQrP
https://youtu.be/qGlUKtjqaEQ?si=aHpBNQnVTY6IrSAE
https://youtu.be/b6R4dElDtRc?si=MqdqWShRFIEa1KbU
https://youtu.be/5YLpjPmsPCA?si=WgH8zdLG99mLMzwT
https://youtu.be/M-Fhb8LzhPo?si=Dqk5uNVxfLWKS4yS
https://dev.to/somadevtoo/19-microservices-patterns-for-system-design-interviews-3o39
 
 
SAGA design pattern:
 
https://youtu.be/Fe_qPM81hJ8?si=MFVIKmZmQ_lV9GrK
https://youtu.be/aOen1-pQLZg?si=DC8PytqTg4uNQxVs
 
CQRS: https://youtu.be/fzGZPf0FMao?si=33-zyAhfBbDI34B1
 
 
Prometheues
https://www.youtube.com/watch?v=2wr9njNdywk&ab_channel=JavaTechie
 
datadog:
https://youtu.be/7T7SyMZihwo?si=pitvrTm47VvtCpMD
 
 
AWS notes revision
 
HLD:
https://www.youtube.com/playlist?list=PL6W8uoQQ2c63W58rpNFDwdrBnq5G3EfT7
 
LLD:
https://www.youtube.com/playlist?list=PL6W8uoQQ2c61X_9e6Net0WdYZidm7zooW
 
roadmap:
https://roadmap.sh/system-design
 
 
AWS EKS:
https://youtu.be/z8qDyO8F3XQ?si=RKxxiNShXLDEguiW














Comparator vs comparable:
both are interfaces used for sorting the list by comparing
comparator for customizing the logic to sort the list we can add n number oo ways to compare the two objects by implementing the comparator interface
@Data
public class Person implements Comparator<Person> {
	private String name;
	private int age;
	private String gender;

	public Person(String string, int i, String string2) {
		this.name = string;
		this.age = i;
		this.gender = string2;
	}

	public Person() {
		// TODO Auto-generated constructor stub
	}

	public static void main(String[] args) {
		Person p = new Person("venkatesh", 27, "male");
		Person p1 = new Person("Adithya", 1, "male");
		Person p2 = new Person("Hanuma", 2, "male");
		List<Person> list = new ArrayList<>();
		list.add(p1);
		list.add(p);
		list.add(p2);
		 Collections.sort(list, new Person());
		System.out.println(list);
	}

	@Override
	public int compare(Person o1, Person o2) {

		return o1.name.compareToIgnoreCase(o2.name);
	}
comparable for natural ordering by the class define itself 
@Data
public class Person extends Person1 implements Comparable<Person> {
	private String name;
	private int age;
	private String gender;
	
	

	public Person(String string, int i, String string2) {
		this.name = string;
		this.age = i;
		this.gender = string2;
	}

	@Override
	public int compareTo(Person other) {

		return Integer.compare(this.age, other.age);
	}

	public static void main(String[] args) {
		Person p = new Person("venkatesh", 27, "male");
		Person p1 = new Person("Hanuma", 1, "male");
		Person p2 = new Person("Hanuma", 2, "male");
		List<Person> list = new ArrayList<>();
		list.add(p1);
		list.add(p);
		list.add(p2);
		Collections.sort(list);
		int x = p.sub();
		System.out.println(list);
	}

	@Override
	public void add() {
		// TODO Auto-generated method stub

	}

sort vs sorted:
sort :it sorts the original list ,used in collection
sorted it will not sort the original list and sorted list will collected in another object of list ,used in streams

no.of ways to sort:
Collections.sort(list);
Collections.sort(list,comparator)
list.sort(comparator)
stream.sorted()
strea.sorted(comparator)
treeset or treemap


string :it is a immutable object ,threadsafe
Stringbuilder:it is used to modify the string ,it is not a thread safe as it is asynchrozied means only one thread can access the object .
               it is fast as compare to strngbuffer because of asynchronization.
Stringbuffer:it is also used to modify the string ,it is thread safe because multithread environment can access the object 

final:a keyword used to declare constans to prevent inheritance and to pervent method overriding
    final variable:the variable whose value cannot be changed
    final method: the method with varible cannot be accessed by subclasses
    final class:the class cannot be subclassed
  

finalize:the finalize method is called to remove free up the memeory .once the garbage collector reaches it will be marked as unreferenced after all marking 
         it will call the finalize method to free up the space

finally :a block that is associtated with try catch blocks ..the block will be executed regardless of exception thrown

wrapper class:A class that is used to encapulate the primitive data in the form of objects is known as wrapper class
              wrapper classes are used during the storage of objects in the collections ..
              as we cannot directly store primitive values ..we can store only objects in the lists..this are immutable
              when an wrapper object is created ..we cannot change the value..when we try to change the value ..a new wrapper is created 


Anonymous class:A class without the name is known as Anonymous class.

interface Age {
    int x = 21;
    void getAge();
}

// Main class
class AnonymousDemo {
  
    // Main driver method
    public static void main(String[] args)
    {

        // A hidden inner class of Age interface is created
        // whose name is not written but an object to it
        // is created.
        Age oj1 = new Age() {
          
            @Override public void getAge()
            {
                // printing  age
                System.out.print("Age is " + x);
            }
        };
      
        oj1.getAge();
    }
}

Age implementation is done with implementing the class 

Abstract method in java:

In oops concept abstraction is defined as hiding the unnecessary details(implementation) and just focus on the functionlity .

Advantages: it increase the efficency.
reduces complexity .
abstraction can be achived using abstract classes and methods 

Abstract class:
a class is declared with abstract keyword .it can have zero or more abstract and non-abstract methods .inorder to implement those methods we need to extend the abstract class .we cannot create instances for the abstract classes .

Any abstract class may or maynot contain abstract methods.

Abstract method:
a method with abstract keyword within the abstract class without implementaion(just with method signature /without body) is known as abstract method .

the subclass which extends the abstract class must implement the abstract methods .
we cannot use final modifier . .
default methods are not allowed in abstract class
we cannot declare abstract methods with the static keyword because static methods cannot be overidden as they are defined in the class itself .


Interface :
Another way of achieving the abstraction is using the interface concept.

there can only abstract methods in interface no body .
it is used to achive abstraction and multiple inheritance in java.
we can have abstract methods and varibles  .
It also represents IS-A relationship
 we cannot create instance same as abstract class .
Note: since java 8 we can have static and default methods in interface .
since java 9 we can have private methods 

by default in interface -> the fields are public static final ,and the methods are public abstract 

Example:
interface example{
int x=10;  // compiler will under stood it as public static final int x=10;
int add(int a, int b); // will understood it as public abstract int add(int a, int b);

} 



there may or may not be abstract methods in interface.
multiple inheritance is provided by the interface concept .because in interface the implementation is provided by the implementaion class .so there is no ambiguity .


NOTE : By using the abstract class we can achive the partialuy abstraction where as by using the interface we can achiveve the fully abstraction


Concrete CLass:A normal class with an implementation for all of its methods and no abstract methods is called a concrete class

Inheritance represents the IS-A relationship which is also known as a parent-child relationship.
Aggregation represents HAS-A relationship where we will insert the class in the another class as a field .

Encapsulation :binding the data and the methods into a single unit is called a class.we can prevent them accessing by using the modifiers .


File handling in java:it invloves in  reading from and  writing to files using varrious classes and methods 
such as:
FileInputStream :reads data from the file in the form of Stream of bytes 
BufferedReader :reads data from the file in the text from the stream of characters
FileOutStream :write the data into the file in the form of bytes
BufferedWriter: write the data into the file in the form of txt .by using try catch file closes automatically instead we need to close manually
 by calling close methods

java 8 features:
1.lambda expression:it is anonymous function that can treated instance of an interfacep.
rovide a clear and concise way to represent a functional interface in a single expression

2.Functional interface :interface that consists of only abstract method and can have multiple default or static methods ,
annotated with @FunctionalInterface so that the interface cannot have more than 1 abstract method

3.StreamAPi:
we can perform the set of operations in the sequences of elements

4.Default methods :
interfaces can now have  default methods so that we can the breaking the method when implementing the interface
Default methods are methods defined in an interface with a default implementation. They allow interfaces to evolve
 by adding new methods without forcing all implementing classes to provide an implementation for the new methods.
Default methods are declared using the default keyword followed by the method signature and the method body.

Inheritance: Default methods can be inherited by implementing classes. If a class does not override the default method, it will use the implementation provided by the interface.
Overriding: Implementing classes can override default methods to provide their own implementation.
Multiple Inheritance: If a class implements multiple interfaces with conflicting default methods, the class must override the method to resolve the conflict.

5.method References

6.Optional class: it is a container object which may or may not contain a value .it is used to avoid nullpointerexception .provides methods to deal
with presence or absence of a value
Example:
Optional<String> optional = Optional.of("Hello");
optional.ifPresent(System.out::println);

7.Date and time APi
8. Base64 Encoding and decoding: java provides a utility class for encoding and decoding

remove duplicate in arrays:
int[] arr = { 1, 2, 2, 5, 7, 1, 3, 5, 7 };
int[] unique = Arrays.stream(arr).distinct().toArray();
2 ways of creating an array:
int[] arr = { 1, 2, 2, 5, 7, 1, 3, 5, 7 };
int[] arr=new int[10];
termianl operations:
In Java 8, terminal operations are the final operations in a stream pipeline that produce a result or a side-effect. 
Once a terminal operation is applied, the stream is consumed and cannot be used further. Here are some common terminal operations
1.forEach
collect
reduce
count
findFirst
findAny
allMatch
anyMatch
noneMatch
SingleTonDesign pattern:implementing singleTonDesign pattern useful for managing one particular instance or component all over the application 
realtime examples:
database connection management-we will configure the database connection once in the application prop file 
and we will use all that instance all over the running application 
logging:
configuration

how the constructor called:
when we create an object using the new kewword ..the new keyword triggers the jvm to allocate the memory for the new object and then constructor will be called
to initialize the object ..if no explicit constructor is defined ..then jvm defines the no argument constrcutor




